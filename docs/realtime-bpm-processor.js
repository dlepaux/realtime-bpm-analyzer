(()=>{var t=.95,e=.05;function s(s,i=.3){let o=t;do{let t=!1;if(o-=e,s(o,(e=>{t=e})),t)break}while(o>i);return{}}function i(t,e){let i=!1,o=.3;if(s(((e,s)=>{i&&s?s(!0):t[e].length>15&&(i=!0,o=e)})),i&&o){const s=function(t,e){const s=[];for(const i of e){if(0===i.interval)continue;i.interval=Math.abs(i.interval);let e=60/(i.interval/t);for(;e<90;)e*=2;for(;e>180;)e/=2;e=Math.round(e);if(!s.some((t=>t.tempo===e&&(t.count+=i.count,t.count)))){const t={tempo:e,count:i.count};s.push(t)}}return s}(e,function(t){const e=[];for(let s=0;s<t.length;s++)for(let i=0;i<10;i++){const o=t[s],n=t[s+i]-o;if(!e.some((t=>t.interval===n&&(t.count+=1,t.count)))){const t={interval:n,count:1};e.push(t)}}return e}(t[o]));return{bpm:function(t,e=5){return t.sort(((t,e)=>e.count-t.count)).splice(0,e)}(s),threshold:o}}return i||console.warn(new Error("Could not find enough samples for a reliable detection.")),{bpm:[],threshold:o}}var o=()=>.3,n=()=>null,r=()=>function(){const s={};let i=t;do{i-=e,s[i.toString()]=[]}while(i>.3);return s}(),l=()=>function(){const s={};let i=t;do{i-=e,s[i.toString()]=0}while(i>.3);return s}(),h=()=>1,a=class extends AudioWorkletProcessor{constructor(){super(),this.bufferSize=4096,this._bytesWritten=0,this._buffer=new Float32Array(this.bufferSize),this.realTimeBpmAnalyzer=new class{constructor(t){this.minValidThreshold=o(),this.timeoutStabilization=n(),this.validPeaks=r(),this.nextIndexPeaks=l(),this.chunkCoeff=h(),this.options={continuousAnalysis:!1,computeBpmDelay:1e4,stabilizationTime:2e4,postMessage:t.postMessage},Object.assign(this.options,t)}reset(){this.minValidThreshold=o(),this.timeoutStabilization=n(),this.validPeaks=r(),this.nextIndexPeaks=l(),this.chunkCoeff=h()}clearValidPeaks(t){console.log(`[clearValidPeaks] function: under ${t}, this.minValidThreshold has been setted to that threshold.`),this.minValidThreshold=Number.parseFloat(t.toFixed(2)),s((e=>{e<t&&(delete this.validPeaks[e],delete this.nextIndexPeaks[e])}))}analyze(t,e,s,o){const n=s*this.chunkCoeff,r=n-s;this.findPeaks(t,s,r,n),this.chunkCoeff++;const l=i(this.validPeaks,e),{threshold:h}=l;console.log("threshold",h),console.log("this.validPeaks",this.validPeaks),o({message:"BPM",result:l}),this.minValidThreshold<h&&(o({message:"BPM_STABLE",result:l}),this.clearValidPeaks(h)),this.options.continuousAnalysis&&(clearTimeout(this.timeoutStabilization),this.timeoutStabilization=setTimeout((()=>{console.log("[timeoutStabilization] setTimeout: Fired !"),this.options.computeBpmDelay=0,this.reset()}),this.options.stabilizationTime))}findPeaks(t,e,i,o){s((s=>{if(this.nextIndexPeaks[s]>=o)return;const n=this.nextIndexPeaks[s]%e,{peaks:r,threshold:l}=function(t,e,s){const i=[],{length:o}=t;for(let n=s;n<o;n+=1)t[n]>e&&(i.push(n),n+=1e4);return{peaks:i,threshold:e}}(t,s,n);if(0!==r.length)for(const t of r)"undefined"!==typeof t&&(this.nextIndexPeaks[l]=i+t+1e4,this.validPeaks[l].push(i+t))}),this.minValidThreshold)}}({postMessage:this.port.postMessage}),this.initBuffer()}initBuffer(){this._bytesWritten=0}isBufferEmpty(){return 0===this._bytesWritten}isBufferFull(){return this._bytesWritten===this.bufferSize}process(t,e,s){return this.append(t[0][0]),this.isBufferFull()&&this.realTimeBpmAnalyzer.analyze(this._buffer,sampleRate,this.bufferSize,(t=>{this.port.postMessage(t)})),!0}append(t){if(this.isBufferFull()&&this.flush(),t)for(const e of t)this._buffer[this._bytesWritten++]=e}flush(){this.initBuffer()}};registerProcessor("realtime-bpm-processor",a)})();