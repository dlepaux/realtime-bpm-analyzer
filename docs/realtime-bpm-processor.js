(()=>{var t=.95,e=.05;function s(s,i=.3){let n=t;do{let t=!1;if(n-=e,s(n,(e=>{t=e})),t)break}while(n>i);return{}}function i(t,e){let i=!1,n=.3;if(s(((e,s)=>{i&&s?s(!0):t[e].length>15&&(i=!0,n=e)})),i&&n){const s=function(t,e){const s=[];for(const i of e){if(0===i.interval)continue;i.interval=Math.abs(i.interval);let e=60/(i.interval/t);for(;e<90;)e*=2;for(;e>180;)e/=2;e=Math.round(e);if(!s.some((t=>t.tempo===e&&(t.count+=i.count,t.count)))){const t={tempo:e,count:i.count};s.push(t)}}return s}(e,function(t){const e=[];for(let s=0;s<t.length;s++)for(let i=0;i<10;i++){const n=t[s],o=t[s+i]-n;if(!e.some((t=>t.interval===o&&(t.count+=1,t.count)))){const t={interval:o,count:1};e.push(t)}}return e}(t[n]));return{bpm:function(t,e=5){return t.sort(((t,e)=>e.count-t.count)).splice(0,e)}(s),threshold:n}}return i||console.warn(new Error("Could not find enough samples for a reliable detection.")),{bpm:[],threshold:n}}var n=()=>.3,o=()=>null,r=()=>function(){const s={};let i=t;do{i-=e,s[i.toString()]=[]}while(i>.3);return s}(),h=()=>function(){const s={};let i=t;do{i-=e,s[i.toString()]=0}while(i>.3);return s}(),l=()=>1,a=class extends AudioWorkletProcessor{constructor(){super(),this.bufferSize=4096,this._bytesWritten=0,this._buffer=new Float32Array(this.bufferSize),this.realTimeBpmAnalyzer=new class{constructor(t){this.minValidThreshold=n(),this.timeoutStabilization=o(),this.validPeaks=r(),this.nextIndexPeaks=h(),this.chunkCoeff=l(),this.options={continuousAnalysis:!1,computeBpmDelay:1e4,stabilizationTime:2e4,postMessage:t.postMessage},Object.assign(this.options,t)}reset(){this.minValidThreshold=n(),this.timeoutStabilization=o(),this.validPeaks=r(),this.nextIndexPeaks=h(),this.chunkCoeff=l()}clearValidPeaks(t){console.log(`[clearValidPeaks] function: under ${t}, this.minValidThreshold has been setted to that threshold.`),this.minValidThreshold=Number.parseFloat(t.toFixed(2)),s((e=>{e<t&&(delete this.validPeaks[e],delete this.nextIndexPeaks[e])}))}analyze(t,e,s,n){const o=s*this.chunkCoeff,r=o-s;this.findPeaks(t,s,r,o),this.chunkCoeff++;const h=i(this.validPeaks,e),{threshold:l}=h;console.log("threshold",l),n({message:"BPM",result:h}),this.minValidThreshold<l&&(n({message:"BPM_STABLE",result:h}),this.clearValidPeaks(l)),this.options.continuousAnalysis&&(clearTimeout(this.timeoutStabilization),this.timeoutStabilization=setTimeout((()=>{console.log("[timeoutStabilization] setTimeout: Fired !"),this.options.computeBpmDelay=0,this.reset()}),this.options.stabilizationTime))}findPeaks(t,e,i,n){s((s=>{if(this.nextIndexPeaks[s]>=n)return;const o=this.nextIndexPeaks[s]%e,{peaks:r,threshold:h}=function(t,e,s){const i=[],{length:n}=t;for(let o=s;o<n;o+=1)t[o]>e&&(i.push(o),o+=1e4);return{peaks:i,threshold:e}}(t,s,o);if(0!==r.length)for(const t of r)"undefined"!==typeof t&&(this.nextIndexPeaks[h]=i+t+1e4,this.validPeaks[h].push(i+t))}),this.minValidThreshold)}}({postMessage:this.port.postMessage}),this.initBuffer()}initBuffer(){this._bytesWritten=0}isBufferEmpty(){return 0===this._bytesWritten}isBufferFull(){return this._bytesWritten===this.bufferSize}process(t,e,s){return this.append(t[0][0]),this.isBufferFull()&&this.realTimeBpmAnalyzer.analyze(this._buffer,sampleRate,this.bufferSize,(t=>{this.port.postMessage(t)})),!0}append(t){if(this.isBufferFull()&&this.flush(),t)for(const e of t)this._buffer[this._bytesWritten++]=e}flush(){this.initBuffer()}};registerProcessor("realtime-bpm-processor",a)})();